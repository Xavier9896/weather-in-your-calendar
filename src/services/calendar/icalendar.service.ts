import { CalendarProvider, CalendarEvent } from '@/interfaces/calendar.interface';
import fs from 'fs/promises';
import path from 'path';

export class ICalendarService implements CalendarProvider {
  private readonly PRODID = '-//Weather in Calendar//v0.2//EN';
  private readonly VERSION = '2.0';

  async generateCalendar(events: CalendarEvent[]): Promise<string> {
    const calendarLines: string[] = [
      'BEGIN:VCALENDAR',
      `VERSION:${this.VERSION}`,
      `PRODID:${this.PRODID}`,
      'X-WR-CALNAME:Weather for ' + events[0]?.location || 'Unknown Location',
      'X-APPLE-CALENDAR-COLOR:#ffffff',
      'CALSCALE:GREGORIAN',
      'METHOD:PUBLISH'
    ];

    for (const event of events) {
      calendarLines.push(...this.generateEvent(event));
    }

    calendarLines.push('END:VCALENDAR');

    return calendarLines.join('\r\n');
  }

  private generateEvent(event: CalendarEvent): string[] {
    const eventLines: string[] = [
      'BEGIN:VEVENT',
      `UID:${this.formatDate(event.startTime)}@weather-calendar`,
      `DTSTAMP:${this.formatDate(new Date())}`,
      `DTSTART;VALUE=DATE:${this.formatDateOnly(event.startTime)}`,
      `DTEND;VALUE=DATE:${this.formatDateOnly(event.endTime)}`,
      `SUMMARY;LANGUAGE=en:${this.escapeText(this.getEventTitle(event))}`,
      'X-FUNAMBOL-ALLDAY:1',
      'X-MICROSOFT-CDO-ALLDAYEVENT:TRUE',
      'URL;VALUE=URI:https://github.com/yourusername/weather-in-your-calendar'
    ];

    if (event.location) {
      eventLines.push(`LOCATION:${this.escapeText(event.location)}`);
    }

    if (event.weather) {
      eventLines.push(`DESCRIPTION;LANGUAGE=en:${this.escapeText(this.generateWeatherDescription(event))}`);
    } else if (event.description) {
      eventLines.push(`DESCRIPTION;LANGUAGE=en:${this.escapeText(event.description)}`);
    }

    eventLines.push('END:VEVENT');
    return eventLines;
  }

  private getEventTitle(event: CalendarEvent): string {
    if (!event.weather) return event.title;
    return `${event.weather.icon} ${event.weather.temperature}Â°C`;
  }

  private generateWeatherDescription(event: CalendarEvent): string {
    if (!event.weather) return event.description || '';

    const lines = [
      `${event.weather.icon} ${event.weather.description}`,
      '',
      `ğŸŒ¡ï¸ æ¸©åº¦: ${event.weather.temperature}Â°C`
    ];

    if (event.weather.humidity !== undefined) {
      lines.push(`ğŸ’§ æ¹¿åº¦: ${event.weather.humidity}%`);
    }

    if (event.weather.pressure !== undefined) {
      lines.push(`âš¡ï¸ æ°”å‹: ${event.weather.pressure}hPa`);
    }

    if (event.weather.wind) {
      lines.push(`ğŸ’¨ é£é€Ÿ: ${event.weather.wind.speed}m/s`);
      lines.push(`ğŸš© é£å‘: ${event.weather.wind.direction}`);
    }

    lines.push('');

    if (event.weather.sunrise) {
      lines.push(`ğŸŒ… æ—¥å‡º: ${this.formatTime(event.weather.sunrise)}`);
    }

    if (event.weather.sunset) {
      lines.push(`ğŸŒ‡ æ—¥è½: ${this.formatTime(event.weather.sunset)}`);
    }

    lines.push('');
    lines.push('Generated by Weather in Calendar');

    return lines.join('\n');
  }

  private formatDate(date: Date): string {
    return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
  }

  private formatDateOnly(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}${month}${day}`;
  }

  private formatTime(date: Date): string {
    return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
  }

  private getNextDay(date: Date): Date {
    const nextDay = new Date(date);
    nextDay.setDate(nextDay.getDate() + 1);
    return nextDay;
  }

  private escapeText(text: string): string {
    return text.replace(/[\\,;]/g, '\\$&').replace(/\n/g, '\\n');
  }

  async saveCalendar(content: string, filename: string): Promise<void> {
    const filePath = path.join(process.cwd(), filename);
    await fs.writeFile(filePath, content, 'utf-8');
  }
} 